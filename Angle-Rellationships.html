<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Transversal & Angle Relationships – Cycling Pair Highlight</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #controls, #categories {
      margin-bottom: 10px;
    }
    #categories button {
      margin-right: 5px;
      margin-bottom: 5px;
    }
    canvas {
      border: 1px solid #000;
      display: block;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Transversal & Angle Relationships – Cycling Pair Highlight</h1>
  
  <!-- Controls -->
  <div id="controls">
    <label for="angleSlider">Transversal Angle (X in degrees): </label>
    <input type="range" id="angleSlider" min="10" max="80" value="45">
    <span id="angleValue">45</span>°
    <br>
    <label>
      <input type="checkbox" id="parallelSwitch" checked> Lines are parallel (Corresponding and Alternate Angles are congruent <b><u>if and only if</u></b> the lines are parallel)
    </label>
  </div>
  
  <!-- Angle Category Buttons -->
  <div id="categories">
    <button id="verticalBtn">Vertical Angles</button>
    <button id="correspondingBtn">Corresponding Angles</button>
    <button id="altInteriorBtn">Alternate Interior</button>
    <button id="altExteriorBtn">Alternate Exterior</button>
    <button id="clearHighlightBtn">Clear Highlight</button>
  </div>
  
  <!-- Canvas -->
  <canvas id="canvas" width="800" height="500"></canvas>
  
  <script>
    // Get DOM elements
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const angleSlider = document.getElementById("angleSlider");
    const angleValueSpan = document.getElementById("angleValue");
    const parallelSwitch = document.getElementById("parallelSwitch");
    
    // Category buttons
    const verticalBtn = document.getElementById("verticalBtn");
    const correspondingBtn = document.getElementById("correspondingBtn");
    const altInteriorBtn = document.getElementById("altInteriorBtn");
    const altExteriorBtn = document.getElementById("altExteriorBtn");
    const clearHighlightBtn = document.getElementById("clearHighlightBtn");
    
    // Global variables for cycling
    let highlightCategory = null; // current category ("vertical", "corresponding", etc.)
    let lastCategory = null;        // last category that was clicked
    let currentPairIndex = 0;       // current index within the current category

    let L1_y = 200;
    let L2_y = 360;
    
    // Pre-defined pairs for each category.
    const verticalPairs = [
      { intersection: "T0", pair: ["1", "3"] },
      { intersection: "T0", pair: ["2", "4"] },
      { intersection: "T1", pair: ["5", "7"] },
      { intersection: "T1", pair: ["6", "8"] }
    ];
    const correspondingPairs = [
      { T0: "1", T1: "5" },
      { T0: "4", T1: "8" },
      { T0: "2", T1: "6" },
      { T0: "3", T1: "7" }
    ];
    const altInteriorPairs = [
      { T0: "1", T1: "7" },
      { T0: "2", T1: "8" }
    ];
    const altExteriorPairs = [
      { T0: "4", T1: "6" },
      { T0: "3", T1: "5" }
    ];
    
    // Draw the simulation diagram.
    // In our ideal configuration (when parallelSwitch is checked):
    //   L₁ is horizontal at y = 300 and L₂ at y = 350.
    //   T₀ is fixed at (200,300).
    //   The transversal passes through T₀ at angle θ (radX).
    //   T₁ is computed as the intersection of the transversal with L₂.
    function drawSimulation() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Get current angle X (in degrees) and convert to radians.
      let X = parseFloat(angleSlider.value);
      angleValueSpan.textContent = X;
      let radX = X * Math.PI / 180;
      
      // Check if lines are parallel.
      let areParallel = parallelSwitch.checked;
      
      // Define L₁ and L₂.
      let L1_p1 = { x: 50, y: L1_y }, L1_p2 = { x: 750, y: L1_y };
      let L2_p1, L2_p2;
      if (areParallel) {
        L2_p1 = { x: 50, y: L2_y };
        L2_p2 = { x: 750, y: L2_y };
      } else {
        L2_p1 = { x: 50, y: 340 };
        L2_p2 = { x: 750, y: 300 };
      }
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";
      ctx.beginPath();
      ctx.moveTo(L1_p1.x, L1_p1.y);
      ctx.lineTo(L1_p2.x, L1_p2.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(L2_p1.x, L2_p1.y);
      ctx.lineTo(L2_p2.x, L2_p2.y);
      ctx.stroke();
      
      // Draw the transversal.
      // T₀ is fixed at (200,300).
      let T0 = { x: 200, y: L1_y };
      let T_start = { x: T0.x - 1000 * Math.cos(radX), y: T0.y - 1000 * Math.sin(radX) };
      let T_end = { x: T0.x + 1000 * Math.cos(radX), y: T0.y + 1000 * Math.sin(radX) };
      ctx.strokeStyle = "blue";
      ctx.beginPath();
      ctx.moveTo(T_start.x, T_start.y);
      ctx.lineTo(T_end.x, T_end.y);
      ctx.stroke();
      
      // Mark T₀.
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(T0.x, T0.y, 5, 0, 2 * Math.PI);
      ctx.fill();
      
      // Compute T₁ (intersection of the transversal with L₂).
      let T1 = null;
      if (areParallel) {
        // L₂ is horizontal at y = 350.
        let dy = L2_y - T0.y; // = 50
        let t = dy / Math.sin(radX);
        T1 = {
          x: T0.x + t * Math.cos(radX),
          y: L2_y
        };
      } else {
        T1 = getIntersection(
          T0,
          { x: T0.x + 1000 * Math.cos(radX), y: T0.y + 1000 * Math.sin(radX) },
          L2_p1,
          L2_p2
        );
      }
      if (T1) {
        ctx.beginPath();
        ctx.arc(T1.x, T1.y, 5, 0, 2 * Math.PI);
        ctx.fill();
      }
      
      // Forced arc definitions at T₀.
      // At T₀, define four rays:
      // R1: horizontal right (0 radians)
      // R2: along transversal (radX)
      // R3: horizontal left (π radians)
      // R4: opposite transversal (π + radX)
      let arcsT0 = [
        { label: "1", start: 0, end: radX },
        { label: "2", start: radX, end: Math.PI },
        { label: "3", start: Math.PI, end: Math.PI + radX },
        { label: "4", start: Math.PI + radX, end: 2 * Math.PI }
      ];
      // At T₁, because L₂ is horizontal, we assign the same reference directions.
      let arcsT1 = [
        { label: "5", start: 0, end: radX },
        { label: "6", start: radX, end: Math.PI },
        { label: "7", start: Math.PI, end: Math.PI + radX },
        { label: "8", start: Math.PI + radX, end: 2 * Math.PI }
      ];
      
      let r = 40; // radius for arcs
      function drawArc(center, arcDef, color) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.arc(center.x, center.y, r, arcDef.start, arcDef.end, false);
        ctx.stroke();
        // Compute midpoint for label placement.
        let mid = (arcDef.start + arcDef.end) / 2;
        let lx = center.x + (r + 15) * Math.cos(mid);
        let ly = center.y + (r + 15) * Math.sin(mid);
        ctx.fillStyle = color;
        ctx.font = "16px sans-serif";
        ctx.fillText(arcDef.label, lx, ly);
      }
      
      // Draw arcs at T₀.
      for (let arc of arcsT0) {
        // Use red for interior (angles 1 and 3) and green for exterior (angles 2 and 4).
        let col = (arc.label === "1" || arc.label === "3") ? "red" : "green";
        drawArc(T0, arc, col);
      }
      // Draw arcs at T₁.
      if (T1) {
        for (let arc of arcsT1) {
          let col = (arc.label === "5" || arc.label === "7") ? "red" : "green";
          drawArc(T1, arc, col);
        }
      }
      
      // If a highlight category is selected, overlay thicker arcs on the specific pair.
      if (highlightCategory) {
        highlightRelationships(T0, T1, arcsT0, arcsT1);
      }
    }
    
    // Helper: compute intersection of two lines given by (p1,p2) and (p3,p4).
    function getIntersection(p1, p2, p3, p4) {
      let x1 = p1.x, y1 = p1.y,
          x2 = p2.x, y2 = p2.y,
          x3 = p3.x, y3 = p3.y,
          x4 = p4.x, y4 = p4.y;
      let denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (denom === 0) return null;
      let t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
      return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
    }
    
    // Function to draw a thicker (highlighted) arc.
    function drawHighlightedArc(center, arcDef, color) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 5;
      ctx.arc(center.x, center.y, 40, arcDef.start, arcDef.end, false);
      ctx.stroke();
    }
    
    // Highlight the angle relationships based on the selected category and currentPairIndex.
    function highlightRelationships(T0, T1, arcsT0, arcsT1) {
      if (highlightCategory === "vertical") {
        // Cycle through verticalPairs.
        let pair = verticalPairs[currentPairIndex];
        if (pair.intersection === "T0") {
          let arcA = arcsT0.find(a => a.label === pair.pair[0]);
          let arcB = arcsT0.find(a => a.label === pair.pair[1]);
          drawHighlightedArc(T0, arcA, "orange");
          drawHighlightedArc(T0, arcB, "orange");
        } else if (pair.intersection === "T1" && T1) {
          let arcA = arcsT1.find(a => a.label === pair.pair[0]);
          let arcB = arcsT1.find(a => a.label === pair.pair[1]);
          drawHighlightedArc(T1, arcA, "orange");
          drawHighlightedArc(T1, arcB, "orange");
        }
      } else if (highlightCategory === "corresponding") {
        let pair = correspondingPairs[currentPairIndex];
        let arcT0 = arcsT0.find(a => a.label === pair.T0);
        let arcT1 = T1 ? arcsT1.find(a => a.label === pair.T1) : null;
        drawHighlightedArc(T0, arcT0, "blue");
        if (T1 && arcT1) drawHighlightedArc(T1, arcT1, "blue");
      } else if (highlightCategory === "altInterior") {
        let pair = altInteriorPairs[currentPairIndex];
        let arcT0 = arcsT0.find(a => a.label === pair.T0);
        let arcT1 = T1 ? arcsT1.find(a => a.label === pair.T1) : null;
        drawHighlightedArc(T0, arcT0, "green");
        if (T1 && arcT1) drawHighlightedArc(T1, arcT1, "green");
      } else if (highlightCategory === "altExterior") {
        let pair = altExteriorPairs[currentPairIndex];
        let arcT0 = arcsT0.find(a => a.label === pair.T0);
        let arcT1 = T1 ? arcsT1.find(a => a.label === pair.T1) : null;
        drawHighlightedArc(T0, arcT0, "purple");
        if (T1 && arcT1) drawHighlightedArc(T1, arcT1, "purple");
      }
    }

    function clearHighlights() {
      highlightCategory = null;
      lastCategoryClicked = null;
      updateAll();
    }

    parallelSwitch.addEventListener('change', function() {
      if(this.checked) {
        clearHighlights();
        correspondingBtn.disabled = false;
        correspondingBtn.innerHTML = "Corresponding Angles";
        altInteriorBtn.disabled = false;
        altInteriorBtn.innerHTML = "Alternate Interior Angles";
        altExteriorBtn.disabled = false;
        altExteriorBtn.innerHTML = "Alternate Exterior Angles";
      }
      else {
        clearHighlights();
        correspondingBtn.disabled = true;
        altInteriorBtn.disabled = true;
        altExteriorBtn.disabled = true;
      }
    });
    
    // Update the simulation.
    function updateAll() {
      drawSimulation();
    }
    
    // Initial draw.
    updateAll();
    
    // Event listeners for controls.
    angleSlider.addEventListener("input", updateAll);
    parallelSwitch.addEventListener("change", updateAll);
    
    // Global variables to hold cycling state.
    let currentPairIndexMap = {
      vertical: 0,
      corresponding: 0,
      altInterior: 0,
      altExterior: 0
    };

    let lastCategoryClicked = null;
    
    // Helper function to handle category button clicks.
    function handleCategoryClick(category) {
      if (lastCategoryClicked === category) {
        // Cycle to next pair.
        if (category === "vertical") {
          currentPairIndexMap.vertical = (currentPairIndexMap.vertical + 1) % verticalPairs.length;
        } else if (category === "corresponding") {
          currentPairIndexMap.corresponding = (currentPairIndexMap.corresponding + 1) % correspondingPairs.length;
        } else if (category === "altInterior") {
          currentPairIndexMap.altInterior = (currentPairIndexMap.altInterior + 1) % altInteriorPairs.length;
        } else if (category === "altExterior") {
          currentPairIndexMap.altExterior = (currentPairIndexMap.altExterior + 1) % altExteriorPairs.length;
        }
      } else {
        // New category: reset its index to 0.
        if (category === "vertical") currentPairIndexMap.vertical = 0;
        if (category === "corresponding") currentPairIndexMap.corresponding = 0;
        if (category === "altInterior") currentPairIndexMap.altInterior = 0;
        if (category === "altExterior") currentPairIndexMap.altExterior = 0;
        lastCategoryClicked = category;
      }
      highlightCategory = category;
      // Set the global currentPairIndex based on the category.
      if (category === "vertical") {
        currentPairIndex = currentPairIndexMap.vertical;
      } else if (category === "corresponding") {
        currentPairIndex = currentPairIndexMap.corresponding;
      } else if (category === "altInterior") {
        currentPairIndex = currentPairIndexMap.altInterior;
      } else if (category === "altExterior") {
        currentPairIndex = currentPairIndexMap.altExterior;
      }
      updateAll();
    }
    
    // Event listeners for category buttons.
    verticalBtn.addEventListener("click", function() {
      handleCategoryClick("vertical");
    });
    correspondingBtn.addEventListener("click", function() {
      handleCategoryClick("corresponding");
    });
    altInteriorBtn.addEventListener("click", function() {
      handleCategoryClick("altInterior");
    });
    altExteriorBtn.addEventListener("click", function() {
      handleCategoryClick("altExterior");
    });
    clearHighlightBtn.addEventListener("click", clearHighlights);
  </script>
</body>
</html>
